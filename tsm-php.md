# 

## echo、print、print_r的区别

echo 不是函数,没有返回值,仅用于打印信息,如果只是输出 echo 会更快
print 有返回值,是函数,还能格式化输出
print_r 则是打印复合类型如数组 对象

## php-fpm的日志正常,但客户端却超时了,你认为可能是哪里出了问题,怎么排查?

检查nginx log，请求是否达到nginx 和是否正常转发给 php-fpm

## self和static的区别

static：如果在子类中重写了父类中的static方法、属性，父类就会去访问了子类的static方法

self: 是类内指针，不管子类有没有重写过父类中的方法、属性都指向本类的静态方法、属性

## PHP的的这种弱类型变量是怎么实现的？

zval联合体

## PHP中发起http请求有哪几种方式？它们有何区别？

curl
stream流的方式
socket方式

## 请求PHP脚本时的过程

1. PHP 初始化执行环节，启动 Zend 引擎，加载注册的扩展模块。
2. 初始化后读取 PHP 脚本文件，Zend 引擎对 PHP 文件进行词法分析，语法分析，生成语法树。
3. Zend 引擎编译语法树，生成 Opcode。
4. Zend 引擎执行 Opcode，返回执行结果。

## Opcache是什么

Opcache是一种通过将解析的PHP脚本预编译的字节码存放在共享内存中来避免每次加载和解析PHP脚本的开销，解析器可以直接从共享内存读取已经缓存的字节码，从而大大提高PHP的执行效率

## CGI FastCGI fpm module 运行模式

cgi：

允许web服务器通过特定的协议与应用程序通信

原理：用户请求 服务器接受 fork子进程调用程序 程序返回内容 服务器接受内容 返回给用户

每次用户请求都要fork进程调用程序，然后销毁。性能较低

fastcgi：

像是一个常驻型cgi，可以一直处理请求不结束进程

原理：fast-cgi初始化 预先fork n个进程 用户请求 服务器接受请求 交给fast-cgi进程管理器 fast-cgi进程管理区接受，给一个空闲的fast-cgi进程处理 处理完成，fast-cgi进程变成空闲状态等待下次请求 服务器接受内容 返回给用户

module模式：

apache+php运行时，默认使用module模式。他把php作为apache的模块随apache一起启动，接收到用户请求时直接调用mod_php模块进行处理并返回给apache

php-cli模式：

属于命令行模式，php 文件名.php直接运行代码

- 没有超时时间
- STDIN/STDOUT标准输入/输出
- 直接打印到控制台中

## PHP设计模式

- 单例模式：保证在整个应用程序的生命周期中，单例类的实例只存在一个
- 工厂模式：定义一个创建对象的接口，让子类去实例化具体类。
- 观察者模式 发布/订阅模式：当一个对象状态发生变化时，依赖它的对象全部会收到通知，并自动更新。
- 适配器模式：将一个类的接口转换成客户希望的接口，使得原本不兼容的接口可以兼容
- 依赖注入模式：是ioc的一种实现方式。用来减少程序中的耦合

## 堆和栈的区别

1. 申请方式的不同。栈由系统自动分配，而堆是人为申请开辟;

2. 申请大小的不同。栈获得的空间较小，而堆获得的空间较大;

3. 申请效率的不同。栈由系统自动分配，速度较快，而堆一般速度比较慢;

4. 存储内容的不同。栈在函数调用时，函数调用语句的下一条可执行语句的地址第一个进栈，然后函数的各个参数进栈，其中静态变量是不入栈的。而堆一般是在头部用一个字节存放堆的大小，堆中的具体内容是人为安排;

5. 底层不同。栈是连续的空间，而堆是不连续的空间。

## `<?php echo count(strlen("http://php.net"))?>`执行结果是什么？

1。

| count($x)                | 值                                     |
| ------------------------ | ------------------------------------- |
| $x 是数组或者实现 Countable 的对象 | 如果是数组，返回数组元素个数，如果是对象，返回 count 方法的返回值。 |
| $x 是 null                | 0                                     |
| $x 是其他类型                 | 1                                     |

## list()函数注意事项

php5从右往左赋值

php7从左往右赋值

## php单引号和双引号的区别？

1. 双引号解释变量，单引号不解释变量

2. 双引号转义特殊字符（/r/n之类的），单引号不解释转义字符。

3. 单引号被系统默认是普通字符串类型，会直接编译

## 如何在命令行运行 php 代码（写出两种方式），如何在命令行向脚本传递参数？

一、`php filename.php` 或者 `php -r "echo 'leonzai@github.com';`

二、`php filename.php arg1 arg2`，如果第一个参数以 `-` 开头，那么必须在第一个参数前传递 `--`，如 `php filename.php -- arg1 arg2`。

## 列举一些 PHP 中的设计模式？

- 单例模式：保证在整个应用程序的生命周期中，单例类的实例只存在一个

- 工厂模式：定义一个创建对象的接口，让子类去实例化具体类。

- 观察者模式 发布/订阅模式：当一个对象状态发生变化时，依赖它的对象全部会收到通知，并自动更新。

- 适配器模式：将一个类的接口转换成客户希望的接口，使得原本不兼容的接口可以兼容

- 依赖注入模式：通过将依赖注入到应用类中来实现解耦

- 池模式：准备一组已初始化的对象池，而不是按需分配和销毁。多用于数据库链接，套接字链接等。

## 简述一下 PHP 垃圾回收机制（GC）

以引用计数机制为基础，同时使用根缓存区机制，当发现有存在循环引用的zval时，就会把其投入到根缓冲区，当根缓冲区达到配置文件中的指定数量后，就会进行垃圾回收，以此解决循环引用导致的内存泄露问题

- 如果引用计数减少到零，所在变量容器将被清除（free），不属于垃圾；

- 如果一个zval的引用计数减少后还大于0，那么它会进入垃圾周期。其次，在一个垃圾周期中，通过检查引用计数是否减1，并且检查哪些变量容<u>器的引用次数是</u>零，来发现哪部分是垃圾。

## PHP的array是真正的数组吗？

在PHP中, 数组是用一种HASH结构(HashTable)来实现的, 通过key值读取，使得可以在O(1)的时间复杂度下实现数组的增删, 并同时支持线性遍历和随机访问.

## 如何解决 PHP 内存溢出问题

1.增大 PHP 脚本的内存分配

2.变量引用之后及时销毁

3.将数据分批处理

## php类的静态调用和实例化调用各自的利弊

静态方法可以直接调用，比实例化效率高，但不能自动销毁

## isset() 和 empty() 区别

isset检测变量是否存在，可以传多个值

empty检测变量是否为空

## 冒泡排序

```php
$a = array(2, 13, 42, 34, 56, 23, 67, 365, 87665, 54, 68, 3);

function quick_sort($a)
{
    // 判断是否需要运行，因下面已拿出一个中间值，这里<=1
    if (count($a) <= 1) {
        return $a;
    }

    $middle = $a[0]; // 中间值

    $left = []; // 接收小于中间值
    $right = [];// 接收大于中间值

    // 循环比较
    for ($i = 1; $i < count($a); $i++) {
        if ($middle < $a[$i]) {
            // 大于中间值
            $right[] = $a[$i];
        } else {
            // 小于中间值
            $left[] = $a[$i];
        }
    }

    // 递归排序划分好的2边
    $left = quick_sort($left);
    $right = quick_sort($right);

    // 合并排序后的数据，别忘了合并中间值
    return array_merge($left, [$middle], $right);
}

print_r(quick_sort($a));
```

## 快速排序

$a = array(2, 13, 42, 34, 56, 23, 67, 365, 87665, 54, 68, 3);

function quick_sort(a)
{
 // 判断是否需要运行，因下面已拿出一个中间值，这里<=1
 if (count(a) <= 1) {
 return $a;
 }

```php
$a = array(2, 13, 42, 34, 56, 23, 67, 365, 87665, 54, 68, 3);

function quick_sort($a)
{
    // 判断是否需要运行，因下面已拿出一个中间值，这里<=1
    if (count($a) <= 1) {
        return $a;
    }

    $middle = $a[0]; // 中间值

    $left = []; // 接收小于中间值
    $right = [];// 接收大于中间值

    // 循环比较
    for ($i = 1; $i < count($a); $i++) {
        if ($middle < $a[$i]) {
            // 大于中间值
            $right[] = $a[$i];
        } else {
            // 小于中间值
            $left[] = $a[$i];
        }
    }

    // 递归排序划分好的2边
    $left = quick_sort($left);
    $right = quick_sort($right);

    // 合并排序后的数据，别忘了合并中间值
    return array_merge($left, [$middle], $right);
}

print_r(quick_sort($a));
```

## 请说明 PHP 中传值与传引用的区别，什么时候传值什么时候传引用?

按值传递：函数范围内对值的任何改变在函数外部都会被忽略

按引用传递：函数范围内对值的任何改变在函数外部也能反映出这些修改

优缺点：按值传递时，php必须复制值。特别是对于大型的字符串和对象来说，这将会是一个代价很大的操作。按引用传递则不需要复制值，对于性能提高很有好处。（优缺点会考到）

## 自动加载的原理

自动加载的原理，就是在我们new一个class的时候，PHP系统如果找不到你这个类，就会去自动调用本文件中的__autoload($class_name)方法，我们new的这个class_name 就成为这个方法的参数。所以我们就可以在这个方法中根据我们需要new class_name的各种判断和划分就去require对应的路径类文件，从而实现自动加载。

## 数组和链表的区别

数组：随机访问性强，查找速度快。但是插入和删除效率低，大小固定不能动态扩展

链表：插入删除快，不会浪费内存，大小不固定。不能随即查找。查找效率低

## PHP 如何实现多继承

1. 接口多继承

2. trait

## include和require的区别是什么？

include在引入不存在文件时会产生一个警告但会继续运行

require会出现一个致命性错误，并不会运行

## swoole 为什么这么快 ？和go有什么区别？

常驻内存：避免重复加载带来的性能损耗，提升海量性能

协程异步：提高对 I/O 密集型场景并发处理能力（如：微信开发、支付、登录等）

区别：

​ swoole使用多线程eventloop处理IO事件，多进程执行用户层php代码

​ go使用单线程eventloop处理IO事件，多线程实现协程调度，执行用户层代码

## 二分算法实现

## select、poll、epoll的原理与区别

select：

同步多路IO复用

fd连接数限制

用轮询方式对socket扫描，效率低

poll：

同步多路IO复用

用链表的方式，使其没有连接数限制

epoll：

select和poll是主动轮询机制，epoll是被动触发的，

epoll会把哪个流发生了怎样的I/O事件通知我们

## laravel tp 启动生命周期

laravel：

- 请求到index.php，判断是否是维护状态

- 自动加载所依赖的第三方包

- 创建应用实例（注册服务提供者，项目基础服务，目录路径）

- 处理请求和相应（中间件和路由分发）

- 请求结束

tp：

- 请求到index.php

- 自动加载依赖包

- 实例化think\app类

- 执行http的run方法(获取当前请求对象，初始化http应用，监听事件)

## 超时时间是由nginx决定还是fpm决定

如果出现 502 bad Gateway的原因一般是 php 程序执行超时 修改php-fpm.conf中的请求时间

如果出现504**GateWay TimeOut**，是nginx转发给fastcgi的请求超时。

## 接口加密

- http：aes, sm4上一套

- https： rsa, sm2上一套

对称加密, 是防止http情况下数据泄漏 https没这个问题 

rsa或者sm2是签名用, 防止对方抵赖.

## 业务代码上线后出现bug如何处理

- 封闭入口，短时间内不要再新增信息

- 重现问题，根据日志或者报错查找bug

- 处理脏数据

## 有 10 亿条订单数据，属于 1000 个司机的，请取出订单量前 20 的司机

（TIPS）不要中招。不要用经常使用思路来处理，10 亿数据 你再怎么优化，全表求和，都是要死人的。

咱们从设计上解决这个问题。只有一千个司机。咱们能够作个简单哈希，分库分表，% 求余数。保证这一千个司机分在一千个表里，每一个人有每一个人的单独表。引擎用 MYSAIM，求表中数据的总数，效率飞快，遍历一千张表，求最大前二十便可。

#### 请写出自少两个支持回调处理的PHP函数

array_map,array_filter, array_walk

## rand与mt_rand的区别

在随机数区间不大的情况下并没有很大的效率差距。但是出现重复数的几率，rand要比mt_rand高很多。
