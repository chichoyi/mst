## 为何需要分布式

单台服务器已经无法承受访问压力
大数据处理
高并发访问
高可用性，自动容错
并行、高性能应用

## 分布式ID的生成方案

UUID：16字符，占用空间比较多；不是有序的。因为innodb索引的b+树的叶子结点是一个有序链表，可能会导致页分裂，分裂后再去挪数据

redis自增：数据丢失；自增，数据量泄露

雪花：因为有一段是通过是时间生成，时钟回拨可能会导致重复

如何选择合适的分布式主键方案呢？

- uuid：性能比较差，且是无序的。因为innodb索引的b+树的叶子结点是一个有序链表，可能会导致页分裂，分裂后再去挪数据

- 雪花：高位补0，机器id和机房id和时间戳。

- redis：原子性自增来做id分发

## 雪花算法生成的ID由哪些部分组成

1. 符号位， 占用1位

2. 时间戳， 占用41位

3. 机器id，  占用10位

4. 序列号，  占用12位

## 分布式锁在项目中的应用场景

1. 分布式系统 集群

2. 操作共享资源：比如库里唯一的用户数据

3. 并发

## 分布式锁的解决方案

1. setnx：setnx加锁，expire设置过期时间。用lua保证这两个命令原子性的；删除的时候要判断自己设置的值是否和删除的值相等，可以用redisson框架做lock和unlock方法

2. zookeeper

3. 数据库主键/唯一索引

## redis分布式锁死锁的情况

1. 加锁没有释放锁，可以添加delete key

2. 加锁后还没 释放，程序就挂掉了，可以用expire设置过期时间

## redis如何做分布式锁

假如有两个服务A B都想获得锁：

step1：服务器为了获得锁，set productId:lock value nx ex 30000。

step2：服务B为了获得锁，也要set productId:lock value1 nx ex 30000。如果已经存在了相同的key并未过期则会执行失败。服务B就会进入循环状态等待执行重新获得锁。

step3：服务A执行超过30秒，key过期自动剔除，此时服务B发送命令执行成功。但是因为A没执行完毕，所以会对A的key进行续期。watch dog

step4：服务A执行完毕，为了释放锁就会主动发起delete key请求，删除前判断服务A持有的value与redis当前value是否一致。lua保证脚本一致性

## Mysql如何做分布式锁

给表设置主键或者unique key，把锁的竞争交给了数据库。处理同一个key时保证了只有一个节点能插入成功，其他都会插入失败

## CAP定理

**概念**

C：一致性，指的是数据在多个副本中保持一致。两个用户访问系统A和B，当A系统数据有变化时，及时同步给B系统，让两个用户看到的数据是一致的。

A：可用性，系统一致处于可用状态。

P：分区容错性，在分布式系统中遇到任何网络分区故障，系统仍然能对外提供服务，网络分区。

**CAP定理**

一个分布式系统中最多只能同时满足CA或者CP。

**原理**

用户1和2分别访问系统A和B，系统A和B通过网络进行同步数据。

理想情况是，用户1访问A修改数据，用户2访问B拿到的是修改的数据。

实际情况是，网络总是不可靠的。

1. 当发生网络故障四，系统A和B没法进行数据同步。也就不满足P，也就是不满足分布式系统了。所以必须满足P

2. CP：用户1访问A修改数据，此时B系统需要同步数据所以要让系统B不可用。

3. AP：用户1访问A修改数据，此时B系统继续提供服务，但是B还在同步数据。牺牲了一致性。

## BASE理论

因为CAP中C和A无法兼得，eBay架构师提出了BASE理论，通过牺牲数据的强一致性来获得可用性。

* `B`asically `A`vailable（基本可用）：分布式系统中出现不可预知的故障时，允许损失部分可用性来保证核心功能的可用。

* `S`oft state（软/弱状态）：允许系统中数据存在中间状态，如支付中。即云居系统在不同节点的数据副本同步过程存在延时。

* `E`ventually consistent（最终一致性）：最终保证数据能够达到一致，不需要实时保证数据的强一致性

例如：在电商平台中，当用户对一个订单发起支付时，通过调用第三方支付平台，第三方并不能即使通知系统，这段时间内就可以给用户状态显示支付中，第三方成功响应后在修改为支付成功。

## TCC解决方案是什么

TCC（Try-Confrim-Cancel）是一种常用的分布式事务解决方案

* T：业务检查阶段，主要进行业务校验和检查；也可能直接进行业务操作

* C：业务确认阶段，这阶段为Try校验过的业务进行确认

* C：业务回滚阶段，和上面的C互斥。失败后回滚业务

## TCC空回滚是解决什么问题的

Try发出请求后，服务没有收到，等待超时后执行了Cancel 。此时Cancel会执行一些逆操作。所以需要在服务中加一个分支事务记录表，在Try中插入一条记录，到Cancel里读取该记录，如果不存在则是空回滚

## 如何解决TCC幂等问题

在分支事务记录表中增加执行状态，每次执行前都查询该状态 

## 如何解决TCC悬挂问题

第二阶段Cancel接口比Try接口先执行。

比如这个接口10s后超时，到了10s时还没开始处理，这时就会执行空回滚操作。Try会有一个预留资源的操作就会被悬挂没有人处理。

解决：在执行第一阶段的时候判断第二阶段是否执行，如果执行就不执行。也就是额外添加一张分支事务的记录表

## 最大努力通知方案的关键是什么

1. 有一定的消息重复通知机制。

2. 消息校对机制。

例如 ：支付时，微信支付会持续向系统推送支付结果。如果没有及时通知到，系统也可以主动向微信支付发起请求。

## 什么是分布式系统中的幂等

任意多次执行所产生的影响均与第一次执行的影响相同。

## 幂等的解决方案

1. 查询操作：查询一次和多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作。

2. 删除操作：也是幂等的。

3. 唯一索引：防止新增脏数据。比如给用户开唯一账户。

4. token机制： 防止页面重复提交，每次请求检查并更新token

## 对外提供的API如何保证幂等

例子：银联提供的接口，需要接入商户提交付款请求时附带source+seq。

source（来源）+seq（序列号）在数据库里做唯一索引，防止多次提交

## 双写一致性问题如何解决

先更新数据库再删除缓存

1. 更新数据库数据

2. 缓存因为种种问题删除失败

3. 将需要删除的key发送到消息队列

4. 自己消费消息，获取需要删除的key

5. 继续重试删除操作，直到成功

## 分布式微服务项目你是怎么设计的

![](https://static01.imgkr.com/temp/9e1ad8115614421692530e7c1f6c8505.png)

## 谈谈对消息队列的理解

优点：

1. 程序解耦：两个程序在交互时，不会因为一方中断而导致服务停止
2. 异步处理：可以同时处理多个请求，缩短响应时长
3. 流量削峰：可以适用在商品秒杀，在客户端请求量很大的时候，有效的进行流量削峰

缺点：

1. 消息可用性降低
2. 系统复杂度提高
3. 数据可能不一致

## 高并发解决

1. 扩容
   
   增加服务器，搭建集群

2. 减少并发/分流/限流
   
   使用异步操作减少并发。
   
   一些数据处理在夜间运行
   
   通过nginx反代，实现负载均衡
   
   数据库分表分库

3. 缓存
   
   浏览器缓存，CDN，ORM缓存，REDIS数据缓存
   
   同时要解决数据一致性问题，缓存雪崩，穿透 击穿

4. 微服务
   
   将并发高得模块拆出来。模块如果挂掉不影响其他模块

5. 程序代码优化
   
   常驻内存模式开发下，尽量减少使用new，使用单例模式，还有连接池的使用

## 消息中间件堆积问题

- 消费端 ：cousume能力弱，机器原因，使用集群

- 服务端：对发送的消息进行筛选，发送逻辑不要太复杂

## MQ的两种工作模式

- 点对点：不可重复消费

- 发布/订阅：可以重复消费

## 发消息时mq挂掉，如何处理

可以设置手动ack，可以把消息记录到表里，后面通过定时再重新推送

uuid：性能比较差，且是无序的。因为innodb索引的b+树的叶子结点是一个有序链表，可能会导致页分裂，分裂后再去挪数据。

雪花：高位补0，机器id和机房id和时间戳。

redis：原子性自增来做id分发

## 异步JOB队列JOB如果有依赖关系，要怎么处理

job可能有3个步骤, 执行第一个, 符合条件,投递第二个job 

执行第二个job, 符合条件, 投递第三个job 

以此类推

123步,是由不同进程/线程完成的
