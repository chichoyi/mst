## Redis和Memcached相比，有哪些优势？

1. redis支持 string list set hash zset，memcached只支持string
2. redis支持数据持久化，可以把内存中的数据持久化到硬盘上，memcached不支持，只能存到内存中，重启就没有数据了。
3. redis使用的是单线程的多路IO复用机制

## 为什么用redis？

因为传统的关系型数据库已经不适用于所用的场景了，比如秒杀时的库存扣减，APP首页的访问流量高峰。很容易把数据库搞崩，所以就需要用到缓存中间件。目前市面上常用的中间件就是redis和mc。

## Redis为什么要把数据放到内存中？

如果不将数据放到内存中，磁盘的IO速度会严重影响性能。

## Redis为什么这么快？

架构：

1. redis的大部分操作在内存中完成，不涉及磁盘IO

2. 为每种类型提供一些操作命令

IO模型：

1. redis是单线程的多路IO复用机制。

2. 在单线程中顺序操作， 没有多线程的困扰不需要锁的复杂度，在操作数据上相对来说是原子性的

## Redis数据类型有哪些？分别应用于哪些场景？

string：缓存，做计数器，分布式系统升自增长ID

list：异步队列，任务轮询，文章列表

hash：记录博客中某个博主的页面访问量，名字，信息

set：微博抽奖，QQ标签，共同关注 好友（交集）

sorted set：排行榜，延迟发送

bitmap：用户签到，用户在线状态

## Redis的过期策略有哪些？

Redis过期策略采用的是惰性删除+定期删除策略

## MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？

redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。

## 大量key集中过期导致卡顿如何解决？

在设置过期时间时，增加一个随机时间

## 缓存雪崩、击穿、穿透如何解决？

- 缓存雪崩：设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，全部转发到数据库中，导致数据库压力过大而崩溃。
  
  可以加给过期时间加一个随机数

- 缓存击穿：某一个key在某个时间点被高并发的访问。
  
  可以采用互斥锁/分布锁。让一个线程去查询，其他线程等待

- 缓存穿透：恶意请求不存在的key，导致缓存无法命中，每次都去查数据库
  
  如果数据库查不到就设置NULL并设置过期时间
  
  对参数做校验，不合法的参数直接return
  
  使用布隆过滤器判断数据是否存在

## 如果有大量的key需要设置同一时间过期，一般需要注意什么？

可能会出现缓存雪崩，我们一般需要在过期时间上加一个随机值。

## 如何保证Redis命令的原子性？

原子性：多个命令要么全部成功，要么全部失败。

通过Lua脚本实现：多个操作写道lua脚本中，redis把整个lua脚本作为整体执行

## 有序集合是怎么排序的？

它给集合中的每一个元素设置分数，按照其分数进行排序，也不允许有重复值

## 缓存的原理

有缓存则读缓存，没缓存则读数据库然后做缓存

## 那你使用过Redis分布式锁么，它是什么回事？

先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记释放。

## 使用过Redis做异步队列么，你是怎么用的？

* 使用list最为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再试。

* list还有个指令叫**blpop**，在没有消息的时候，它会阻塞住直到消息到来。

* 使用pub/sub主题订阅者模式，可以实现 1:N 的消息队列。在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如**RocketMQ**等。

## 持久化方式有哪些？有什么区别？

RDB做全量持久化，AOF做增量持久化。因为RDB会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要AOF来配合使用。在redis实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态。

## REDIS 的AOF选项有哪几种写入配置？

在redis.conf文件中，设置：appendonly yes（默认为no）

## 为什么AOF日志需要重写

当AOF很大的时候，再去追加是很慢的，这时可以把多条命令压缩成一条，这就是AOF重写

## redis缓存如何回收

通过设置回收策略。

一般经验规则：

- 使用allkeys-lru策略：当你希望你的请求符合一个幂等律分布，也就是说，你希望部分的子集元素比其他元素被访问的更多。如果你不确定选什么，这是个很好的选择

- 使用allkeys-random：如果你是循环访问，所有的键被连续的扫描，或综合你希望请求分布正常（所有元素被访问的概率差不多）

- 使用volatile-ttl：如果你想通过创建缓存对象时设置TTL时，来决定哪些对象应该被删除

设置TTL也是需要耗费内存的，所有allkeys-lru更合适。

**回收进程如何工作**

- 一个客户端运行了新的命令，添加了新的数据

- redis检查内存使用情况，如果大于maxmemory的限制，则根据执行好的策略开始回收。一个新的命令被执行，等待。

- 所以我们不断的穿越内存限制的边界，通过不断达到边界然后不断的回收回到边界以下。

## redis与mysql冷热数据处理

将新增来的数据存到redis中，定期将热数据保存到mysql中，再将redis中的冷数据删除。周而复始。

业务代码上线后出现bug如何处理

- 封闭入口，短时间内不要再新增信息

- 重现问题，根据日志或者报错查找bug

- 处理脏数据

## 假设现在有多个入口可以同时使用一个账户操作，这个账户只有十块钱，有哪些方法可以使得不超扣消费？

使用悲观锁

redis:lua脚本

队列

## 秒杀实现方式

排队队列和抢购结果队列及库存队列。高并发情况，先将用户进入排队队列，用一个线程循环处理从排队队列取出一个用户，判断用户是否已在抢购结果队列，如果在，则已抢购，否则未抢购，库存减 1，写数据库，将用户入结果队列。

前端：

- 静态化：将活动页面上所有可以静态显示的元素全部静态化，尽量减少动态元素。

- 限流：针对某个ip，限制单位之间内的请求数量

- 禁止重复提交：提交之后按钮禁用

后台：

- 限制uid访问频率

- 把请求写到消息队列中，在用数据库订阅消息减库存，再返回给用户端

- 应对读多写少的业务可以用缓存来分担数据库压力

- redis：将所有DB操作放到队列中排队，使用串行处理。

## 跳表原理

在原有的有序链表上增加了多级索引，通过索引来实现快速查询，提高搜索性能

## zset底层怎么实现

zset的编码有**ziplist**和**skiplist**两种。

底层分别使用**ziplist（压缩链表）**和**skiplist（跳表）**实现。

其实有序集合单独使用字典或跳跃表其中一种数据结构都可以实现，假如我们单独使用 字典，虽然能以 O(1) 的时间复杂度查找成员的分值，但是因为字典是以无序的方式来保存集合元素，所以**每次进行范围操作的时候都要进行排序**；假如我们单独使用跳跃表来实现，虽然能执行范围操作，**但是查找操作有 O(1)的复杂度变为了O(logN)**。因此**Redis使用了两种数据结构来共同实现有序集合。**

- ##### 什么时候使用ziplist什么时候使用skiplist？

当zset满足以下两个条件的时候，使用ziplist：

> 1. 保存的元素少于128个

> 2. 保存的所有元素大小都小于64字节

不满足这两个条件则使用skiplist。

## redis做延迟队列

zset, 要发送的内容id作为key, score是发送时间.

因为时间是有序的. 第一个没到发送时间,后面的肯定也没到

每次检测第一个., 如果没到发送时间, 休眠0.5秒. 否则就开始根据ID取出内容发送.

这样发送的内容都不在内存中

这是分发器的实现，分发器将到时间了要发送的推到队列，由发送器去即时发送

实现已读未读

采用Redis中zSet，以消息id为val，用户点击时的时间戳为score，数据结构如下： 

key={NAME_SPACE}:{msgType}:{userId} 

zSet: val={msgId} ; score={timestamp}

## redis做延迟队列/预约到点发短信的业务

zset, 要发送的内容id作为key, score是发送时间.

因为时间是有序的. 第一个没到发送时间,后面的肯定也没到

每次检测第一个., 如果没到发送时间, 休眠0.5秒. 否则就开始根据ID取出内容发送.

这样发送的内容都不在内存中这是分发器的实现，分发器将到时间了要发送的推到队列，由发送器去即时发送

## 使用bitmap来判断某用户是否在线

只需要一个key，然后用户id为偏移量offset，如果在线就设置为1，不在线就设置为0，3亿用户只需要36MB的空间。

```php
$status = 1;

$redis->setBit('online', $uid, $status);

$redis->getBit('online', $uid);
```

## 使用bitmap来统计活跃用户

使用时间作为key，然后用户id为offset，如果当日活跃过就设置为1。之后通过bitOp进行二进制计算算出在某段时间内用户的活跃情况。

```php
$status = 1;

$redis->setBit('active_20170708', $uid, $status);

$redis->setBit('active_20170709', $uid, $status);
```

$redis->bitOp('AND', 'active', 'active_20170708', 'active_20170709'); 由于是长尾的记录，所以key主要由uid组成，设定一个初始时间，往后每加一天即对应value中的offset的位置。

```
```php
$start_date = '20170708';

$end_date = '20170709';

$offset = floor((strtotime($start_date) - strtotime($end_date)) / 86400);

$redis->setBit('sign_123456', $offset, 1);
//算活跃天数

$redis->bitCount('sign_123456', 0, -1)
```

## 集群高可用

高可用（High Availability），是当一台服务器停止服务后，对于业务及用户毫无影响。 停止服务的原因可能由于网卡、路由器、机房、CPU负载过高、内存溢出、自然灾害等不可预期的原因导致，在很多时候也称单点问题。

1. 主备：主机对外提供服务并将数据同步到备份机，主机挂掉后备机开始服务。缺点是大多数时间从机是空闲的。
   
   主从：一主多从。
- master挂掉后，通过选举算法将slave机选举为master继续对外提供服务，但是ip会发生变化。

- 另一个目的是进行读写分离。解决单机下压力过高问题。主机只提供写或少量读，通过负载均衡算法将读分流到slave机上。
2. 数据同步：
- 同步：当主机接受写操作后，以同步方式写到从机上，然后返回给客户端。（数据强一致性），当有多台从机时，也可以将一台主机一台从机进行同步，让这台从机给其他从机备份。

- 异步：主机接受到写操作后，直接返回客户端。通过异步方式同步到从机上。（数据弱一致性）。从机发生宕机无法保证数据完整性。　　　主从采用异步方式。
