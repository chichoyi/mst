## ACID是靠什么保证的？

- 原子性：由undolog日志来保证，它记录了要回滚的日志信息，事务回滚时撤销已经执行成功的sql

- 一致性：由其他三大特性保证，程序代码要保证业务上的一致性

- 隔离性：由MVCC来保证

- 持久性：由redolog来保证，mysql修改数据的时候会在redolog中记录一份日志数据，就算数据没有保存成功，只要日志保存成功了，数据就不会丢失

## 分库分表的设计

应该是先按业务垂直分库 再到按业务垂直分表 然后就是 按字段水平分表

- 水平分库：以字段为依据，按照range、hash策略，将一个库中的数据拆分到多个库中

- 水平分表：以字段为依据，按照range、hash策略，将一个表中的数据拆分到多个表中

- 垂直分库：以表为依据，按照业务归属不同，将不同的表拆到不同的库中

- 垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表中

-分表分库常用中间件 sharding-jdbc 和 mycat

## limit 1000000 加载很慢的话，你是怎么解决的呢？

- 如果id是连续的，可以返回上次查询的最大记录，再往下limit

- 在业务允许的情况是下限制页数 ，是否需要如此靠后的数据

- order by + 索引 （id为索引）

## mysql中in 和exists的区别

如果子查询的表数据比主查询中的少，适合用in。如果子查询的表数据比主查询中的多，适合用exists

## 数据库自增主键可能遇到什么问题？

- 使用自增主键进行分表分库时，会造成主键重复问题，可以使用UUID。

- 自增主键可能会用完

## 百万级别或以上的数据，你是如何删除的？

- 先删除表中的索引，在删除数据，在创建索引

## 数据库中间件了解过吗，sharding jdbc，mycat？

sharding-jdbc基于jdbc驱动，无需额外的proxy。Mycat基于proxy

## MySQL的主从延迟，你怎么解决？

- 主从复制分了五个步骤进行：
1. 主库的更新写入到binlog

2. 从库发起连接，连接到主库

3. 主库创建一个binlog dump thread发送到从库，将binlog发送的从库

4. 从库创建一个I/O线程，读取主库传来的binlog内容写入到relay log

5. 从库创建一个sql线程，从relay log中读取内容，将内容写入到从库

这种问题，注意了。划重点。问你出现问题，寻找解决方案的时候，一定要对症下药，也就是说这个问题你可以这样考虑，什么情况下导致的主从延迟。

1. 如果主库和从库服务器配置不一样，从库的差点，那么就可能导致延迟时间加长。这时候，换成相同的服务器配置服务器即可。

2. 从库压力太大了。一般主从了，从库基本用来查询，比如可能运营或者开发者自己都在从库上进行一系列的 sql 操作。那简单呗。多配几个从库，分摊压力，一主多从。

3. 大事务。比如 delete 这种语句 不 limit 限制一下，如果数据量过大，导致主库运行时都花费了长时间，再同步到从库，这个时间间隔过长。

## 什么是数据库连接池?为什么需要数据库连接池呢?

数据库连接池原理：在内部对象池中，维护一定数量的数据库连接，并对外暴露数据库连接的获取和返回方法

- 资源重用

- 提高响应速度

- 统一管理，避免数据库链接泄漏

## 一条SQL语句在MySQL中如何执行的？

1. 先连接到数据库

2. 查询缓存，大多数情况下不建议用缓存，因为缓存失效很频繁

3. 分析器，如果没有命中缓存，就需要对语句及逆行解析

4. 优化器，经过优化器进行处理，优化器是在表里面有多个索引时，决定使用哪个索引，或者一个语句有多表关联时决定各个表的连接顺序

5. 执行器，判断表是否有查询权限，如果有，则根据表的引擎定义，去使用这个引擎提供的接口

## mysql 的内连接、左连接、右连接有什么区别？

- 内连接，只返回匹配的结果集

- 左连接，返回左表的所有行，即时右表没有匹配的记录

- 右连接，返回右表的所有行，即时左表没有匹配的记录

## 说一下数据库的三大范式

1. 数据库表的每一列都是不可拆分的

2. 在1的基础上 每一列都与主键直接相关

3. 在2的基础上，每一列数据都与主键直接相关

## 主从复制binlog格式有哪几种？有什么区别？

STATEMENT，基于语句的日志记录，把所有写操作的sql语句写入 binlog （默认）

ROW，基于行的日志记录，把每一行的改变写入binlog

MIXED，混合模式

## Mysql主从复制方式？有什么区别？

- 异步模式：主节点不会主动push bin log到从节点，这样有可能导致failover的情况下，也许从节点没有即时地将最新的bin log同步到本地。

- 半同步模式：这种模式下主节点接收到一个从节点返回的信息就会commit；否则需要等待超时后切换为异步模式在提交，可以使主从数据库的数据延迟变小，但不能保证从节点将事务更新到db中。

- 全同步模式：主节点和从节点全部执行了commit并确认才会向客户端返回成功

## 为什么需要主从同步

1. 读写分离

2. 主备

3. 分布式

## Mysql主从同步

在master机器上，主从同步事件会被写到binlog中;在slave机器上，slave读取主从同步事件，并根据读取的事件变化，在slave库上做相应的更改。

## 现在有3张表，1个主表，2个副表，主表数据大概在1W左右，副表大概在1000W和2000W左右，怎么优化？

首先，确保每条数据不会产生null值，然后合理建立索引，合理写SQL，避免select *之类的方式，用什么就取什么。

## Mysql给一个大表加一列_MySQL 大表添加一列的实现

5.6之前, 加触发器自动完成.

5.6及之后, 使用在线DDL语句

## 数据库存储日期格式时，如何考虑时区转换问题？

- datetime 类型适用于数据原始的创建时间，修改其他字段值时，datetime 字段不会改变

- timestamp 类型会记录数据最后一次修改的时间，且自动更新

## 列出一些防范SQL注入、XSS攻击、CSRF攻击的方法

转义关键字符，使用PDO预处理方式

过滤输入，使用htmlspecialchars过滤转义

使用token验证 使用验证码

## 拖库 洗库 撞库

拖库：

通过对目标网站扫描，查找漏洞，进行sql注入，文件上传在服务器建立后门(webshell)获取root权限，下载数据库

避免：

对数据库密码进行加密，设置黑白名单。

用户要单独设置密码，定义修改密码。

洗库：

获取用户数据后，将数据变现。

撞库：

将数据在其他网站上进行登录。

避免：

一段时间内密码超过次数封ip，加入验证码。

## 防止sql注入

1. 进行sql预编译

2. 过滤转义参数

3. 确认每种数据的类型

4. 确认数据长度

5. 设置数据库权限

6. sql异常信息用自定义代码响应

## id为什么要自增

因为底层可能是B+树，可能有也分裂，不是自增，页面会变得碎片化，数据不是顺序去写

## Inoodb快照读和当前读

- **快照读：读取的是记录的可见版本（有可能是历史版本），不加锁。**

- **当前读：读取的是记录的最新版本，并且当前读返回的记录都会加上锁，保证其他事务不会再并发修改这条记录。**

快照读实现：mvcc

当前读实现：主要靠加锁（行记录锁+间隙锁）实现，保证其他事务不会再并发修改这条记录。

## MySQL 索引使用有哪些注意事项呢？

优点：

- 提高查询速度 

- 在查询过程中，优化器会选择适合的索引提高系统性能
  
  索引哪些情况下会失效

- 查询条件包含or 会导致索引失效

- 组合索引中，查询时要按照最左原则进行where条件判断

- like中 "%asdg"会导致索引失效

- 对索引进行函数操作或加减会导致索引失效

- *索引中使用!= 或者 not in 会失效

- *隐式转换也会失效 比如字段是int 却用where age='1'

- 不适用的场景

- 数据量少的情况下不建议用索引

- 离散低的不建议用索引如 sex 男女

- 频繁更新的字段不建议加索引

## 日常工作中你是怎么优化SQL的？

- 加索引
1. 查询条件包含or 会导致索引失效

2. 组合索引中，查询时要按照最左原则进行where条件判断

3. like中 "%asdg"会导致索引失效

4. 对索引进行函数操作或加减会导致索引失效

5. 对索引进行函数操作或加减会导致索引失效

6. 索引中使用!= 或者 not in 会失效
- 数据处理多时要分批次进行

- 尽量避免使用2个表以上的join

- 满足三大范式

- 主从复制读写分离

- 分表分库
  
  -...

## 索引是存在与内存还是磁盘

磁盘，如果存在内存，每次重连加载索引是很浪费时间的

## 说一说Mysql最左前缀匹配

建立联合索引时会遵循最左前缀匹配的原则

对abc三列建立联合索引

实际是建立了a ab abc 三个索引

对量大的数据表，可以减少开销

## 如何写sql能够有效的使用到复合索引？

注意查询sql条件的顺序，确保最左匹配原则有效

## 一张表建立了abc联合索引，where b 能不能命中？

不能，如果where b=1 and a=2 可以命中，因为优化器会做优化

## 索引有哪些优缺点？

- 唯一索引可以保证数据库表中每一行数据的唯一性

- 索引可以加快查询速度，减少查询时间

- 创建索引和维护索引需要时间

- 表中数据进行增删改时，索引也要动态的维护

## 索引有哪几种类型？

1. 主键索引：数据列不允许重复 不允许为空 只能有一个主键

2. 唯一索引：数据列不允许重复 允许为空 可以创建多个索引

3. 普通索引： 允许为空 可以创建多个索引

4. 全文索引：通过倒排索引提高检索速度，可以对文本的内容进行分词，搜索

5. 覆盖索引：查询列要被所建的索引覆盖，不必读取数据行

6. 组合索引：多个列组成一个索引，用于组合搜索

## 数据库中主键和唯一索引的区别？

1. 主键为一种约束，唯一索引为一种索引，本质上就不同。

2. 主键在表中只能有一个，唯一索引可以有多个。

3. 主键创建后一定包含唯一性索引，而唯一索引不一定就是主键。

4. 主键不能为null,唯一索引可以为null.

5. 主键可以被其它表引用，唯一索引不能。

6. 主键和索引都是键，主键是逻辑键，索引为物理键，即主键不实际存在。

## 索引底层是什么数据结构？

B + 树。

## 为什么用的是 B + 树，不能使用红黑树或者其他的？

可以使用红黑树。但是这样的话可能会造成树的高度过高，意味着相同查询下，会进行更多的磁盘 I/O，影响性能，而 B+ 树可以保持树的高度不至于过高

## 数据库索引的原理，为什么要用 B+树，为什么不用二叉树？

1）当数据量大时，树的高度会比较高（树的高度决定着它的IO操作次数，IO操作耗时大），查询会比较慢。

2）每个磁盘块（节点/页）保存的数据太小

## Hash索引和B+树区别是什么？你在设计索引是怎么抉择的？

1. B+支持范围搜索

2. B+支持联合索引的最左原则

3. B+支持order by

4. B+支持like模糊

5. hash等值查询效率高

hash：查询单条快，范围查询慢，因为数据时散列分布的。memory（基于内存）默认

btree：b+数，层数越多，数据量指数级增长。innodb（基于磁盘）默认

## 创建索引的三种方式

- create index index_name on table table_name(column)

- alter table table_name add index index_name(column)

## InnoDB引擎中的索引策略，了解过吗？

覆盖索引：

​ 在普通索引树中可以得到查询的结果，不需要在回到主键索引树中再次搜索

​ 如果select * from table where age between 12 and 25，这样会回表再查一次

​ select id from table where age between 12 and 25，就不会进行回表。减少了搜索次数，叫做覆盖索引

最左前缀：

​ 原则就是经常用的列有优先

​ 离散型高的优先

​ 宽度小的列优先

索引下推：

​ 在索引遍历过程中，会对索引包含的字段先判断，直接过滤掉不满足条件的记录。减少回表次数

## 覆盖索引、回表等这些，了解过吗？

- 覆盖索引：查询列要被所创建的索引覆盖，这样查询数据时不会去查询数据列

- 回表：二级索引无法直接查询所有列的数据，所以通过二级索引查询到聚簇索引后，再查询到想要的数据，这种通过二级索引查询出来的过程，就叫做回表。

## B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据？

当查询使用聚簇索引时，不需要回表查询

## 非聚簇索引一定会回表查询吗？

不一定，如果查询语句的字段全部命中了索引，那么就不必再进行回表查询

举个简单的例子，假设我们在学生表的上建立了索引，那么当进行select age from student where age < 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。

## 聚簇索引与非聚簇索引的区别

mysql的索引类型跟存储引擎有关

- innodb：数据文件和索引文件全部放在ibd文件中；

- myisam：数据文件放在myd文件中，索引文件放在myi文件中；只有非聚簇索引

- 一个表中只能拥有一个聚集索引，而非聚集索引一个表可以存在多个。

- 聚集索引，索引中键值的逻辑顺序决定了表中相应行的物理顺序；非聚集索引，索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同

## 一条查询sql以主键查和二级索引查区别

1、如果查询语句是 select * from table where ID = 100,即主键查询的方式，则只需要搜索 ID 这棵 B+树。

2、如果查询语句是 select * from table where k = 1，即非主键的查询方式，则先搜索k索引树，得到ID=100,再到ID索引树搜索一次，

这个过程也被称为回表。

## mysql的分页查询，越往后翻越慢怎么办

通过explain可以看到扫描的行数（rows）越来越大，可以利用索引覆盖减少回表的耗时

![](https://img2020.cnblogs.com/blog/2149481/202009/2149481-20200914114054979-676573322.png)

```sql
SELECT * from table_name order by id desc limit 10000000,1;

OK, Time: 17.751000s
```

```
SELECT id from table_name order by id desc limit 10000000,1; 

OK, Time: 5.370000s
```

## 什么是事务？

指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。

## MySQL事务得四大特性以及实现原理

- 原子性：要么全部执行，全部不执行

- 一致性：事务开始前后，数据不会被破坏

- 隔离性：事务与事务之间互相隔离，不会冲突

- 持久性：会永久的保存到数据库中

## 事务运行的三种模式

1. 自动提交事务

每条单独的语句都是一个事务，每个语句都隐含一个commit

2. 显式事务

以begin transaction 开始，以commit 或 rollback 结束

3. 隐性事务

在前一个事务完成时，新事务隐式启动，但每个事务仍以commit或rollback显示结束

## 事务的隔离级别有哪些？MySQL的默认隔离级别是什么？

> 读脏：一个事务对数据进行了修改但未提交，另一个事务也在访问这个数据并且读到了修改的数据

> 不可重复读：A事务多次读，B事务在A读取中修改了数据，可能造成结果不一致

> 幻读：一个事务在读取某一范围数据的时候，另一个事务在该范围内插入了新行，再次读取的时候与之前的数据不一致

**不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表**

1. 读未提交
- 这种事务隔离级别下，select语句不加锁，此时可能不一致的数据，读脏。是并发最高，一致性最差的隔离级别
2. 读提交 RC
- 可能会出现不可重复读
3. 可重复读 RR
- 无论读几次都不会读到重复的数据
4. 串行化
- 如果有未提交的事务正在修改某些行，所有读取这些行的select就会被堵塞住，一致性最好的，但并发性最差的隔离级别。

## MVCC底层原理

特点：保证了访问的效率和数据一致

![img](https://img-blog.csdnimg.cn/20200725024356278.png)

MVCC只在RC和RR下才有效。

​ 在每个表的后面有三个隐藏字段 行ID、事务ID、回滚指针

​ ReadView由未提交的事务ID数组和已提交的最大事务ID组成

ReadView策略不同：

​ RC下每执行一次select都会重新生成一个ReadView。

​ RR下只会在第一次select执行时生成，后续沿用第一次的ReadView

版本链：

​ 在版本链中拿出最上面的事务ID开始逐个进行对比

​ 有一个最小事务ID和最大事务ID。分别在已提交事务和未提交事务区间边缘。中间夹着未提交和已提交事务

​ 当这个版本的事务ID比最小事务小时，则是可见的。

​ 当这个版本的事务ID比最大事务大时，则是不可见的。

​ 落在中间时，有两种情况

​ 第一种：在未提交事务中，是不可见的

​ 第二种：在已提交事务中，是可见的

## InnoDB与MyISAM的区别

// 事务 索引 锁

- I 支持事务，M不支持事物

- I 支持外键，M不支持 外键

- I 支持MVCC，M不支持

- select count(*) from table 时 M快，因为他有一个变量存着表的总行数，I需要全表扫描

- I 支持表 行锁，M只支持表锁

## 常见锁问题

锁超时：

- 行锁：优化sql，及时提交事务，同一事务下资源开销较大放到最后

- 表锁：优化sql，DDL变更尽量在业务低峰执行

死锁：

## MySQL 遇到过死锁问题吗，你是如何解决的？

步骤：

- 查看死锁日志show engine innodb status;

- 找出死锁sql

- 分析sql加锁情况

- 模拟死锁案发

- 分析死锁日志

- 分析死锁结果

有P1P2两个进程，都需要A和B两个资源，现在P1持有A等待B，P2持有B等待A，现在两个都等待另一个资源而不肯释放资源，就会无限等待，导致死锁

## 怎么加读写锁

LOCK TABLE my_table_name READ; 用读锁锁表，会阻塞其他事务修改表数据。

LOCK TABLE my_table_name WRITe; 用写锁锁表，会阻塞其他事务读和写。

## 数据库的乐观锁和悲观锁

- 悲观锁 ，任何事务都不能对数据进行修改，只能等待锁被释放后才能执行

- 乐观锁，先把线程放进来，如果没有其他线程对数据进行修改则可以修改成功，否则修改失败或者重试。

## select for update有什么含义， 锁表还是锁行还是其他？

- 是悲观锁，用索引是行锁，没有是表锁

## 一个事务正在更新另一个事务也想更新这个表的一行记录，如果判断是否有冲突

事务A上行锁时，对表上一个写意向锁。在对某行上一个写锁。

事务B相对表上写锁时，先检查表是否上了行锁或表锁，然后在检查是否背上了意向锁。

## InnoDB有哪几种锁？

1. 共享锁和排他锁
- 如果没有指定某行，两个都是行锁否则就是表锁

- share： for share 允许多个事务同时读同一记录，互不干扰，但不允许加其他锁

- exclusive： for update 只有一个事务可以写数据
2. 意向锁 Intention
- 未来某个时间要加 share/ exclusive 锁

- 是一个表级别的锁
3. 记录锁 Record
- 行锁，避免重复读和脏读问题
4. 间隙锁 gap
- 封锁索引记录中的间隔，防止其他事务在间隔中插入数据，解决幻读问题，只会出现在RR级别中。
5. 插入意向锁 insert intention
- 在行插入之前由插入操作设置的一种间隙锁
6. 自增锁 auto-inc
   
   -AUTO-INC锁是一种特殊的表级锁，由插入到具有自动增量列的表中的事务使用。

7. 下一个键锁（临界锁） Next-Key
   
   临键锁，是记录锁与间隙锁的组合，它的封锁范围，既包含索引记录，又包含索引区间。
   
   更具体的，临键锁会封锁索引记录本身，以及索引记录之前的区间。

## 在高并发情况下，如何做到安全的修改同一行数据？

1. 使用悲观锁
- for update ，本次事务提交之前，别的线程都无法修改这些记录
2. 使用乐观锁
- 有线程进来，先放过去修改，如果看到别的线程没修改过，就可以修改成功。如果别的线程修改过，就修改失败或者重试

## SQL慢的原因与优化

**原因**：

索引：

SQL：分页查询优化，优化写入语句

数据库：垂直分表

架构：主从，读写

优化：

定位慢查询sql show processlist

explain分析执行计划

## 怎么处理Mysql的慢查询

- 开启慢查询：比如说设置超过1s执行时间写到日志中

- 业务中的sql语句是否查询了多余的行

- explain分析索引

- 分表

## SQL优化的一般步骤是什么，怎么看执行计划（explain），如何理解其中各个字段的含义？

1. show status 了解各种sql的执行频率

2. 通过慢日志定位那些执行效率低的sql语句

3. explain分析低效的sql执行计划

`id`：sql执行顺序，由大到小执行

select_type：查询每个select查询的类型

`type`：ALL，index，`range`，ref，eq_ref

`table`：用到的表

possible_keys：使用那个索引找到的这行

`key`：实际使用的索引

key_len：索引最大长度

ref：那列用到了索引

`rows`：扫描出的行数

`extra`：Using filesort 索引排序，Using index ，Using where

## 如果某个表有近千万数据，CRUD比较慢，如何优化？

- 优化sql语句，加索引，适当反三范式，适当冗余

- 可以将一部分常用的数据存到redis中

- 主从复制，读写分离

- 水平分库分表，垂直分库分表

## 一条sql执行过长的时间，你如何优化，从哪些方面入手？

- 是否用到了多表和子查询，优化sql结构，比如除去冗余字段

- 优化索引结构，是否可以适当增加索引

- 分表分库

- explain分析sql语句

- 主从复制 读写分离

- 查看mysql 慢日志

## Mysql占用cpu过高

- show processlist语句，查找cpu占用最高的SQL语句，优化该SQL，比如适当建立某字段的索引

- 打开慢查询日志，将那些执行时间过长且占用资源过多的SQL拿来进行explain分析

- 考虑定时优化文件及索引

- 考虑是否是锁问题

- 如果数据量过大，可以考虑使用MySQL集群或者搭建高可用环境。
