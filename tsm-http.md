## 输入URL访问网页的过程/web工作原理

1. 用户在浏览器输入网址

2. dns服务器解析/或者本机hosts,路由器hosts对比 获得ip

3. 浏览器访问默认端口80,则访问的tcp地址为 ip:80

4. tcp协议3次握手,建立连接

5. 发送一个http request请求头

6. 服务器获得http request请求头,表明该次访问为http访问,解析http请求头,获得请求类型,请求格式,以及请求数据(cookie,get,post数据)

7. 服务器发送response响应数据,主动断开

8. 浏览器接收response响应数据,解析响应文本类型,解析数据,断开连接

## web开发方面会遇到哪些缓存，分别如何优化

浏览器缓存

在任何现代浏览器上 (如 IE, FireFox, Chrome) 折腾清除隐私数据的对话框，你很可能会注意到 “缓存” 这个设置项。

代理服务器缓存

Web 代理服务器使用同样的缓存原理，只是规模更大。代理以同样的方式服务千万用户，大公司和 ISP 经常在他们的防火墙或者单独的设备（也被称为中介 (intermediaries)）上架设代理缓存。

网关缓存

也被称为 “反向代理缓存” 或 “替代缓存”。网关缓存同样是起中介作用的，不过不是网络管理员部署的，而多半是网站管理员（公司专门的运维工程师、或 UED 或程序组某人 Add）部署，这样更容易扩展与维护。

## session和cookie的区别是什么

1. session存在服务器端，cookie存在浏览器端，session比较安全

2. 禁用cookie后，session也会失效，但是可以通过url中传递session_id来实现。

3. session可以放在文件，数据库，内存中

## session是存储在什么地方，以什么形式存储的

session是存在服务器的内存中 通过sessionId区分是哪个会话,以键值对的形式存储

## 实现session共享

使用redis/mem/mysql作为session存储可以实现多台服务器同一个session_id访问到相同的session内容

## 说一下多进程和多线程的区别

进程是资源分配的最小单位，线程是CPU调度的最小单位

1. 内存/cpu：多进程占用内存多，切换复杂，cpu利用率低。多线程占用内存少，切换简单，CPU利用率高

2. 创建/销毁：多进程创建销毁速度慢 ，多线程速度快

3. 编程调试：进程编程/调试简单，线程复杂

4. 可靠性：进程间不会相影响。一个线程挂掉将导致整个进程挂掉

## 协程与线程区别

Swoole的协程在底层实现上是单线程的，因此同一时间只有一个协程在工作，协程的执行是串行的。这与线程不同，多个线程会被操作系统调度到多个CPU并行执行。

一个协程正在运行时，其他协程会停止工作。当前协程执行阻塞IO操作时会挂起，底层调度器会进入事件循环。当有IO完成事件时，底层调度器恢复事件对应的协程的执行。

对CPU多核的利用，仍然依赖于Swoole引擎的多进程机制。

## 协程与进程

协程只是一串运行在进程中的任务代码,只是这些任务代码可以交叉运行

协程并不是多任务并行,属于多任务串行,每个进程在一个时间只执行了一个任务

## TCP/IP五层模型？都有什么协议？详细功能？

1. 应用层（应用层，表示层，会话层）
   
   为用户的应用进程提供网络通信服务
   
   协议：域名系统DNS协议、HTTP协议、SMTP协议等

2. 传输层
   
   负责两台主机之间的数据传输，使得数据能从发送端传输到接收端
   
   协议：TCP协议和UDP协议

3. 网络层
   
   负责地址管理和路由选择，在复杂的网络环境中确定一个合适的路径
   
   协议：IP协议

4. 数据链路层
   
   负责设备之前的数据帧的传送和识别，将网络层交下来的数据报封装成帧，在同一个数据链路节点的两个设备之间传输
   
   协议：MTU协议和ARP协议

5. 物理层
   
   实现相邻计算机节点之间比特流的透明传输，尽可能屏蔽掉具体传输介质的差异
- 应用层：为用户提供常用的应用程序，每个网络应用对应着不同的协议。例如文件运输访问和管理，电子邮件等。HTTP SMTP

- 表示层：主要负责数据格式的转换，确保一个系统的应用层发送的消息可以被另一个系统的应用层读取；数据加密

- 会话层：负责网络中两节点的建立，在数据传输中维护计算机网络中两台计算机之间的通信连接，并决定何时终止通信（建立或解除与其他接点的联系）

- 传输层：实现两个用户进程间端到端的可靠通信，处理数据包的错误等传输问题 TCP UDP

- 网络层：逻辑地址寻址，实现不同网络之间的路径选择 IPv4 v6 ARP

- 数据链路层：建立逻辑连接、进行硬件地址寻址

- 物理层： 建立,维护,断开物理连接

## 进程之间通信IPC

进程间的通信叫 IPC （InterProcess Communication），指在不同进程之间传播或交换信息。

IPC 的方式 有 **管道（无名管道和命名管道）、消息队列、信号量、共享存储、Socket**（支持不同主机上的两个进程IPC）

- **管道**
  
  在内核中申请一块固定大小的缓冲区，程序有读写权利，它是一种特殊的文件，不属于任何文件系统，只存在于内存中。面向字节流、自带同步互斥机制、半双工，单向通信，两个管道实现双向通信。

- - 无名管道：一般使用fork函数实现父子进程通信。
  
  - 命名管道：用于没有血缘关系的进程也可以进程间通信。

- **消息队列**
  
  在内核中创建一队列，队列中的每个元素是一个数据报，不同进程可以通过句柄访问这个队列。消息队列独立与发送和接受进程，可以通过顺序和消息类型读取。消息队列可以实现双向通信。

- **信号量**
  
  在内核中创建一个信号量合集（数组），信号量（数组的元素）都是1，使用P操作-1，使用V操作+1，通过对临界资源进行保护实现多进程的同步。

- **共享内存**
  
  将同一块物理内存一块映射到不同的进程的虚拟地址空间中，实现不同进程对同一资源共享。是目前最快的IPC形式，直接从内存中直接读取。由于共享资源是临界资源，操作室需要保证原子性，可使用信号量或互斥锁。

- **socket**
  
  socket是应用层与TCP/IP协议通信的中间软件抽象层，是一组接口，复杂的TCP/IP协议隐藏在Socket接口后面。socket是一种“open-read/write-close”的模式实现，服务器和客户端鸽子维护一个“文件”，建立连接打开后可以向自己文件写入内容共对方读取或者读取对方的内容，通讯结束时关闭文件。是一种可以网间通信的方式。

## HTTP中GET和POST的区别

1. GET在浏览器回退时是无害的，而POST会再次提交请求。

2. GET产生的URL地址可以被Bookmark，而POST不可以。

3. GET请求会被浏览器主动cache，而POST不会，除非手动设置。

4. GET请求只能进行url编码，而POST支持多种编码方式。

5. GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

6. GET请求在URL中传送的参数是有长度限制的，而POST没有。

7. 对参数的数据类型，GET只接受ASCIl字符，而POST没有限制。

## http和https区别，常用方法都有哪些，加密过程

- https 的加密是既是对称又是非对称，既使用了对称(加密消息体)又使用了非对称(加密对称 key)

区别：

1. https协议需要到CA申请证书

2. http信息是明文传输，https有安全性的ssl/tls加密传输协议

3. 连接方式不同，端口也不同。

4. http的连接时无状态的，https是由ssl/tls+http构建的可进行加密传输、身份认证的网络的协议

加密：

1. 对称加密：靠一个密钥加密和解密数据。由客户端发送密钥给服务器，客户端将加密后的数据发送给服务器，服务器用相同的密钥解密数据。

2. 非对称加密：服务器端把公钥传给客户端，客户端拿着公钥对数据进行加密，然后客户端发送加密过的数据到服务器，服务器将加密后的数据用私钥解密

## 对称加密和非对称加密相关

1. 对称加密：采用单钥加密方法，同一个密钥可以同时作为信息的加密和解密。 算法公开，计算量小，速度快。双方都需要保存这个密钥

2. 非对称加密：两个密钥进行加密解密，服务器存着公钥和私钥，发送给浏览器端公钥进行加密传输信息。 速度慢但是能保证安全

## Http协议有什么组成？

请求报文包含三部分：

- 请求行：包含请求方法、URI、HTTP版本信息

- 请求首部字段

- 请求内容实体
  
  响应报文包含三部分：

- 状态行：包含HTTP版本、状态码、状态码的原因短语

- 响应首部字段

- 响应内容实体

## 连接双全工http

http1.1以下为**短链接**：TCP连接发送信息等待接受信息之后断开

http1.1:**半双工**

http2.0是**全双工**

## HTTP 1.x和HTTP 2.0的区别

1. 新的二进制格式：1.x的解析是基于文本的，而2.0是采用二进制格式解析的

2. 多路复用：每一个request都是用作连接的，一个request对应一个id，接收方可以根据request的id将request归属到不同的服务器请求中

3. header压缩：1.x不支持header数据的压缩，2.0进行了压缩，使数据体积变小，传输更快

4. 服务器推送：2.0引入了server push，服务端可以推送资源给浏览器。

## 什么是Http协议无状态协议？怎么解决Http协议无状态协议？

无状态协议对于事务处理没有记忆能力。可以通过cookie session保存

## http协议中，服务器如何区分不同用户？

服务端可以通过User-Agent获得用户的浏览器信息,可以通过cookie获取自定义的信息

- 用户A第一次进入,没有附带cookie

- 服务端记录这个用户,响应头增加一个set_cookie:id=1的cookie

- 浏览器获得响应头,解析到set_cookie动作,把id=1存进cookie

- 第二次请求服务端,带上id=1的cookie,服务端就可以知道:这次请求时用户A请求的

- 同理,用户B第一次进入,服务端响应set_cookie:id=2

可以看出,只要用户端每次请求,跟服务端约定好一个参数作为用户标识,服务端就可以通过这个标识区分不同的用户了

## token原理？

- 用户A第一次进入,通过验证机制(账号密码登陆)请求服务端token

- 服务端验证成功,给用户发送一个token(针对用户)

- 服务端根据token,在服务端存储对应的数据(文件,mysql,redis等)

- 用户A端获取到token,存储到用户端本地

- 用户A请求某接口,带上token

- 服务端通过token,验证用户有效性,返回数据

## 单点登录实现原理

单点登录是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统的保护资源，若用户在某个应用系统中进行注销登录，所有的应用系统都不能再直接访问保护资源

## 长连接、短连接的区别和使用

长连接：client与server建立连接，连接后不断开。且一直存在。

短连接：client与server在通讯时才建立连接。完成后久会断开。

长连接常用于socket通信，短链接常用于web http服务

## TCP和UDP区别、应用场景

区别：

1. 连接性：TCP建立连接需要三次握手，断开连接需要四次握手。 UDP不需要建立连接。

他们的区别是 TCP 是需要连接的 会经过三次握手，而且可以保证消息的可靠性。UDP 是不需要连接的，不保证消息的可靠性

2. 可靠性：TCP利用握手，ACK应答和重传机制，UDP没有

3. 有序性：TCP利用seq序列号对包进行排序，UDP没有

应用场景：

TCP：效率要求相对低但对准确性要求高的场景，例如文件传输，远程登陆，接收重要信息

UDP：效率要求较高但准确性相对低的场景，实时通讯，广播

## 三次握手过程？四次挥手过程

三次握手：

```
1. 首先服务器监听某个端口，客户端发起请求 携带 syn 数据包 (第一次)

2. 服务端接收到这个数据包，返回 syn/ack 的数据包给客户端 (第二次)

3. 最后客户端再次发送一个 ack 的数据包（第三次)。
```

四次挥手：

1. 客户端发送一个FIN（关闭连接），用来关闭客户端到服务器的数据传送，此时客户端进入FIN_WAIT_1状态

2. 服务器收到FIN后，发送一个ACK给客户端，确认序号为收到需要+1（与SYN相同，一个FIN占用一个序号)，此时服务器进入CLOSE_WAIT状态

3. 服务器发送一个FIN，用来关闭服务器到客户端的数据传送，服务器进入LAST_ACK状态

4. 客户端收到FIN后，客户端进入TIME_WAIT状态，接着发送一个ACK给服务器，确认序号为收到的序号+1，服务器进入CLOSED状态

## 传输层主要有哪些协议？

主要有 TCP 和 UDP 协议。他们的区别是 TCP 是需要连接的 会经过三次握手，而且可以保证消息的可靠性。UDP 是不需要连接的，不保证消息的可靠性。

## 什么是心跳机制？

心跳就是业务层来提供一个连接判断是否存活

1. 客户端定时发送一个心跳包，告诉服务器，服务器定时检测所有客户端。看最后一个心跳包的时间长短。如果过长则主动关闭这个连接。

2. 服务器定时询问所有的客户端。如果没有反馈则关闭连接。

### **两种心跳方案有什么区别？**

第一种，对服务和网络压力小，但需要客户但配合。

第二种对服务器和网络压力大。

## WebSocket原理

浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。在此WebSocket 协议中，为我们实现即时服务带来了两大好处：

- Header: 互相沟通的Header是很小的-大概只有 2 Bytes

- Server Push: 服务器的推送，服务器不再被动的接收到浏览器的请求之后才返回数据，而是在有新数据时就主动推送给浏览器。

## 负载均衡

HTTP重定向：

1. 请求到负载均衡服务器

2. 服务器返回304，重定向到实际负责处理的服务器ip给浏览器 Ip在响应头的location中

3. 浏览器请求该服务器

4. 服务器响应数据到浏览器

缺点：

1. 请求经过两次服务器，增加了响应时间

2. 暴露了实际的服务器ip，安全性低

DNS负载均衡：

1. 用户请求域名，请求到DNS服务器

2. DNS解析程ip返回给客户端，并不返回给浏览器进行重定向

3. 客户端拿到ip请求服务器

4. 服务器返回响应数据

可以不用每次都请求负载的ip，可以把返回到客户端的ip缓存起来，重复值使用，提高性能

dns不会暴露真实ip

反向代理负载均衡：

代理服务器来接受请求，然后将请求转发给内网服务器，再将获得的内容返回给客户端。

## 跨域问题

- JSONP
- 设置响应头允许跨域 Access-Control-Allow-Origin
- nginx做反代，请求不同项目，用路径方式区分，请求到nginx做拦截，转发给不同ip和端口

## CSRF攻击原理

登录受信任的网站A，在本地生成cookie

在不登出A的情况下，访问危险网站B

这时B要求访问A，发送一个request，并带上cookie

因为A不知道是用户还是b发出来的，就会处理请求

## 提权

1. 系统漏洞提权 linux windows
   
   windows：漏洞编号 exp
   
   linux：exp

2. 数据库提权
   
   通过执行数据库语句、数据库函数等方式提升服务器用户的权限。

3. 系统配置错误提权

4. 权限继承类提权

5. 第三方软件地权

6. WebServer漏洞提权

## 持久化连接和非持久化连接的区别。

持久连接：使用同一个TCP连接可以发送和接收多个http请求/应答。

非持久连接：一个TCP连接只能发送和接收一个http请求/应答。

mysql和mysqli redis的connect 和pconnect

脚本结束后连接就被释放

脚本结束后连接不被释放

## json和xml区别,各有什么优缺点

* 可读性方面：基本相同，XML的可读性比较好；

* 数据体积方面：JSON相对于XML来讲，数据体积小，传递的速度比较快；

* 数据交互方面：JSON与javascript的交互更加方便，更容易解析处理，更好的数据交互；

* 数据描述方面：XML对数据描述性比较好；

* 传输速度方面：JSON的速度远远快于XML。
